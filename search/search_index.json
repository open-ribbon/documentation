{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Open-Ribbon's Vib-Ribbon Technical Database! This documentation is currently under construction, so as a result, many things about it will change over time, whether it be the information provided or the visual and technical aspects of the repository. This info repository was made by the Open-Ribbon server , a server dedicated to decompiling and researching Vib-Ribbon for the Sony PlayStation. Additionally, for full documentation on the documentation engine, MkDocs, visit here . What is Vib-TD? Much like the Discord server it is based from, the Vib-Ribbon Technical Database is what contains most of the information about the game that we currently know of, whether it be related to the game's source code, bugs that have been discovered, oddities, non-game topics, etc. What is Vib-Ribbon? For those who may not be in the loop, Vib-Ribbon is a game created by Masaya Matsuura, following the release of the smash success that was PaRappa the Rapper. It was released on the original PlayStation by his company NanaOn-Sha in Japan on December 9, 1999, and in Europe on August 30, 2000. It would not see an American release until the European ROM was mirrored over to the PlayStation Network to be available globally, during October 2014 after some unexpected hype during an official event. Navigating the Vib-TD [Stuff on how to navigate the documentation. This will be finalized as we add more stuff.]","title":"Index"},{"location":"#what-is-vib-td","text":"Much like the Discord server it is based from, the Vib-Ribbon Technical Database is what contains most of the information about the game that we currently know of, whether it be related to the game's source code, bugs that have been discovered, oddities, non-game topics, etc.","title":"What is Vib-TD?"},{"location":"#what-is-vib-ribbon","text":"For those who may not be in the loop, Vib-Ribbon is a game created by Masaya Matsuura, following the release of the smash success that was PaRappa the Rapper. It was released on the original PlayStation by his company NanaOn-Sha in Japan on December 9, 1999, and in Europe on August 30, 2000. It would not see an American release until the European ROM was mirrored over to the PlayStation Network to be available globally, during October 2014 after some unexpected hype during an official event.","title":"What is Vib-Ribbon?"},{"location":"#navigating-the-vib-td","text":"[Stuff on how to navigate the documentation. This will be finalized as we add more stuff.]","title":"Navigating the Vib-TD"},{"location":"how-to-help/","text":"How to Help Providing complete documentation of an entire game, such as vib-ribbon, is no small task. We welcome any and all constructive collaboration! It would only make sense to lay down the method of making your mark on this site. To put it simply, each page is a Markdown file. Each page is located in the docs/ directory of the documentation repository . To make edits to the repo, you need to fork it and clone your fork to your computer. Edit the markdown as you would normally, but if you don't know how to work with Markdown, you can find the documentation for it here . To add a new page to the navigation, edit mkdocs.yml and follow the correct formatting convention in the file. For more help on MkDocs, once again, the documentation for that tool is found here . To set up MkDocs on your computer, you need Python installed. From there, pip install mkdocs should be your next step. After that, you should be good to go. As a side note, running mkdocs serve in the repository of your fork should run your site on localhost, where you can see your changes in action before you make your commit or merge request.","title":"How to Help"},{"location":"how-to-help/#how-to-help","text":"Providing complete documentation of an entire game, such as vib-ribbon, is no small task. We welcome any and all constructive collaboration! It would only make sense to lay down the method of making your mark on this site. To put it simply, each page is a Markdown file. Each page is located in the docs/ directory of the documentation repository . To make edits to the repo, you need to fork it and clone your fork to your computer. Edit the markdown as you would normally, but if you don't know how to work with Markdown, you can find the documentation for it here . To add a new page to the navigation, edit mkdocs.yml and follow the correct formatting convention in the file. For more help on MkDocs, once again, the documentation for that tool is found here . To set up MkDocs on your computer, you need Python installed. From there, pip install mkdocs should be your next step. After that, you should be good to go. As a side note, running mkdocs serve in the repository of your fork should run your site on localhost, where you can see your changes in action before you make your commit or merge request.","title":"How to Help"},{"location":"decompilation/_sn_cpp_structors/","text":"_sn_cpp_structors() Within main executables, there exists a method that initializes objects of classes, which is called a constructor. These constructors will be called for object creation. Names for these are not yet finalized as some of them still read \"UnkCtor\" FontHack__Ctor FileSys__Ctor TmdLineObj__Ctor Movie__Ctor InputSys__Ctor UnkCtor00 UnkCtor01 UnkCtor02 UnkCtor03 UnkCtor04 The procedure for getting all of these initialized is to make all the objects needed immediately or at least as soon as possible. The way that vib-ribbon takes care of this is to make an array _CTOR_LIST__ with all of the above constructors. The _sn_cpp_structors() is then run inside start() . void __fastcall _sn_cpp_structors(int sectionobj, int sectionobj_end) { void (**ctor)(void); // Iterate through every entry in the _CTOR_LIST__ array. for ( ctor = (void (**)(void))sectionobj; (int)ctor < sectionobj_end; ++ctor ) { // Run constructor inside its respective class. if ( *ctor ) (*ctor)(); } }","title":"_sn_cpp_structors()"},{"location":"decompilation/_sn_cpp_structors/#_sn_cpp_structors","text":"Within main executables, there exists a method that initializes objects of classes, which is called a constructor. These constructors will be called for object creation. Names for these are not yet finalized as some of them still read \"UnkCtor\" FontHack__Ctor FileSys__Ctor TmdLineObj__Ctor Movie__Ctor InputSys__Ctor UnkCtor00 UnkCtor01 UnkCtor02 UnkCtor03 UnkCtor04 The procedure for getting all of these initialized is to make all the objects needed immediately or at least as soon as possible. The way that vib-ribbon takes care of this is to make an array _CTOR_LIST__ with all of the above constructors. The _sn_cpp_structors() is then run inside start() . void __fastcall _sn_cpp_structors(int sectionobj, int sectionobj_end) { void (**ctor)(void); // Iterate through every entry in the _CTOR_LIST__ array. for ( ctor = (void (**)(void))sectionobj; (int)ctor < sectionobj_end; ++ctor ) { // Run constructor inside its respective class. if ( *ctor ) (*ctor)(); } }","title":"_sn_cpp_structors()"},{"location":"decompilation/file-ext/","text":"File Extraction Written by ILovezCartoonz, aka ILC-YTP Click here to access the original gist This is a guide on how to extract files from Vib-Ribbon. It'll also go over how to repackage files, letting you mod the game. Do note that this guide is based on using Windows, but you should still be able to do everything on Linux with a few adjustments. You'll also need some knowledge on how to navigate CMD/Powershell, or whatever terminal you use. Extracting From BIN/ISO file You'll need: - A copy of Vib-Ribbon on your computer. - A program that can read and extract files from the \"disc.\" Any program that can extract files from a bin or iso file is fine, but if you wanna rebuild the iso/bin file for later, consider using DUMPSXISO, which comes included with MKPSXISO . Run through CMD/Powershell, and remember to add -s whateverfilename.xml to set it up to recompile itself as a bin/iso file later on. EX: dumpsxiso -s rebuild.xml \"Vib-Ribbon (Europe) (En,Fr,De,Es,It) (Track 1).bin\" Extracting PAK files You'll need VibRipper . There's no GUI for the program, it can only be run from a CMD or Powershell window. Basically, when you find a pak file you wanna extract, paste the program into where the pak file is, open a CMD/powershell window, and then enter the command to extract the pak file. EX: vibripper u FILES.PAK FILES_EXT More info can be found on the github page PAL NOTE: The PAL version of the game has a bunch of pak files that are basically the same, only with some models and text changes for the different languages. 01_FILES = Japan Models (TMD) There does exist a Vibri model on the models resource website to download . But, if you don't like how it was compiled, or if you wish to make your own version/rig, or if you wanna mess with animations, continue reading this section. If you're using blender then consider this blender plugin . You can easily port the models in, as well as all the animations and camera angles/animations. It's as accurate as you can get, and what I recommend even if you don't wanna use blender for your purpose, since you can then export the result to whatever you need. Instructions on how to install are listed on the page. If for some reason the addon fails to work correctly, uninstall it, open the zip file and delete the readutil file and replace it with this folder . However, if you insist on not using blender, TMD2LWO and a program that can read LWO (LightWave Objects) files will be needed. Use TMD2LWO the same way as Vib-Ripper was used. EX: TMD2LWO.EXE MODEL.TMD WORM Animations (ANM and ANC) ANM are character/model animation files, while ANC are camera animation files. You can port them through blender with the addon mentioned above. Just make sure you select the whole model before importing the character animations. Images/Textures (TIM) TIM files are the texture files. Vib-Ribbon only uses textures during start-up, with the \"Sony Computer Entertainment inc. Presents\" text and NanaOn-Sha logo. On PAL, there is another texture that replaces the \"SCE INC\" screen, making it go unused. TIM2VIEW allows you to view TIM files, export them as PNGs and replace textures. When editing the extracted PNGs, you'll need to use an image editor that'll export the images with the same color palette and bit depth, or else reimporting the images back to TIM2VIEW will mess with the colors. I used GIMP and it worked well for editing and exporting the textures. Use the Palette and Colormap windows to edit colors. When you wanna export, make sure Save resolution, Save Color Profile and Automatic Pixelformat are set before exporting the images. To replace an image, simply import the image to TIM2VIEW while on the same tab of the TIM you wanna replace. Once imported, the texture contained in the TIM file will automatically get replaced and overwritten. Do note that the color pallete will remain the same, and you'll need to edit each color one at a time from the program. Best to keep the amount of colors you use small if you don't want the process to be long and tedious. AUDIO (VB and VH) Use PSound (ALT VERSION) . VB files contain all the audio clips. VH has audio header data. Can extract audio, but currently no known way to replace audio. Read more about VAB audio here. Rebuilding PAK files When unpacking PAK files, VibRipper will make a text file that'll be needed to make a pak file. EX: vibripper r 01_FILES_EXT 01_FILES.PAK_TOC.txt Make sure to back up the pak file before repacking just in case it doesn't get overwritten and potentially lose progress or waste time trying to get a new one. Making a BIN/ISO file Earlier, I mentioned MKPSXISO, which is what we'll be using to make the bin/iso file. We'll use the xml file DUMPSXISO created earlier. Simply run the program through CMD and specify the xml file. EX: mkpsxiso.exe rebuild.xml You'll get a new bin+cue file named mkpsxiso.bin/.cue. Consider editing the xml file to change the name of the bin+cue file names. Also consider editing the .cue file if you want to include your own custom music tracks in the game.","title":"File Extraction"},{"location":"decompilation/file-ext/#file-extraction","text":"Written by ILovezCartoonz, aka ILC-YTP Click here to access the original gist This is a guide on how to extract files from Vib-Ribbon. It'll also go over how to repackage files, letting you mod the game. Do note that this guide is based on using Windows, but you should still be able to do everything on Linux with a few adjustments. You'll also need some knowledge on how to navigate CMD/Powershell, or whatever terminal you use.","title":"File Extraction"},{"location":"decompilation/file-ext/#extracting-from-biniso-file","text":"You'll need: - A copy of Vib-Ribbon on your computer. - A program that can read and extract files from the \"disc.\" Any program that can extract files from a bin or iso file is fine, but if you wanna rebuild the iso/bin file for later, consider using DUMPSXISO, which comes included with MKPSXISO . Run through CMD/Powershell, and remember to add -s whateverfilename.xml to set it up to recompile itself as a bin/iso file later on. EX: dumpsxiso -s rebuild.xml \"Vib-Ribbon (Europe) (En,Fr,De,Es,It) (Track 1).bin\"","title":"Extracting From BIN/ISO file"},{"location":"decompilation/file-ext/#extracting-pak-files","text":"You'll need VibRipper . There's no GUI for the program, it can only be run from a CMD or Powershell window. Basically, when you find a pak file you wanna extract, paste the program into where the pak file is, open a CMD/powershell window, and then enter the command to extract the pak file. EX: vibripper u FILES.PAK FILES_EXT More info can be found on the github page PAL NOTE: The PAL version of the game has a bunch of pak files that are basically the same, only with some models and text changes for the different languages. 01_FILES = Japan","title":"Extracting PAK files"},{"location":"decompilation/file-ext/#models-tmd","text":"There does exist a Vibri model on the models resource website to download . But, if you don't like how it was compiled, or if you wish to make your own version/rig, or if you wanna mess with animations, continue reading this section. If you're using blender then consider this blender plugin . You can easily port the models in, as well as all the animations and camera angles/animations. It's as accurate as you can get, and what I recommend even if you don't wanna use blender for your purpose, since you can then export the result to whatever you need. Instructions on how to install are listed on the page. If for some reason the addon fails to work correctly, uninstall it, open the zip file and delete the readutil file and replace it with this folder . However, if you insist on not using blender, TMD2LWO and a program that can read LWO (LightWave Objects) files will be needed. Use TMD2LWO the same way as Vib-Ripper was used. EX: TMD2LWO.EXE MODEL.TMD WORM","title":"Models (TMD)"},{"location":"decompilation/file-ext/#animations-anm-and-anc","text":"ANM are character/model animation files, while ANC are camera animation files. You can port them through blender with the addon mentioned above. Just make sure you select the whole model before importing the character animations.","title":"Animations (ANM and ANC)"},{"location":"decompilation/file-ext/#imagestextures-tim","text":"TIM files are the texture files. Vib-Ribbon only uses textures during start-up, with the \"Sony Computer Entertainment inc. Presents\" text and NanaOn-Sha logo. On PAL, there is another texture that replaces the \"SCE INC\" screen, making it go unused. TIM2VIEW allows you to view TIM files, export them as PNGs and replace textures. When editing the extracted PNGs, you'll need to use an image editor that'll export the images with the same color palette and bit depth, or else reimporting the images back to TIM2VIEW will mess with the colors. I used GIMP and it worked well for editing and exporting the textures. Use the Palette and Colormap windows to edit colors. When you wanna export, make sure Save resolution, Save Color Profile and Automatic Pixelformat are set before exporting the images. To replace an image, simply import the image to TIM2VIEW while on the same tab of the TIM you wanna replace. Once imported, the texture contained in the TIM file will automatically get replaced and overwritten. Do note that the color pallete will remain the same, and you'll need to edit each color one at a time from the program. Best to keep the amount of colors you use small if you don't want the process to be long and tedious.","title":"Images/Textures (TIM)"},{"location":"decompilation/file-ext/#audio-vb-and-vh","text":"Use PSound (ALT VERSION) . VB files contain all the audio clips. VH has audio header data. Can extract audio, but currently no known way to replace audio. Read more about VAB audio here.","title":"AUDIO (VB and VH)"},{"location":"decompilation/file-ext/#rebuilding-pak-files","text":"When unpacking PAK files, VibRipper will make a text file that'll be needed to make a pak file. EX: vibripper r 01_FILES_EXT 01_FILES.PAK_TOC.txt Make sure to back up the pak file before repacking just in case it doesn't get overwritten and potentially lose progress or waste time trying to get a new one.","title":"Rebuilding PAK files"},{"location":"decompilation/file-ext/#making-a-biniso-file","text":"Earlier, I mentioned MKPSXISO, which is what we'll be using to make the bin/iso file. We'll use the xml file DUMPSXISO created earlier. Simply run the program through CMD and specify the xml file. EX: mkpsxiso.exe rebuild.xml You'll get a new bin+cue file named mkpsxiso.bin/.cue. Consider editing the xml file to change the name of the bin+cue file names. Also consider editing the .cue file if you want to include your own custom music tracks in the game.","title":"Making a BIN/ISO file"},{"location":"decompilation/resources/","text":"Resources and Setup How to decompile If you want to help us research the game, and even reverse engineer, you will need the following things: Basic C and C++ knowledge A disassembler (IDA Pro or Ghidra is recommended) Instructions for Ghidra You will need Ghidra 10.3.1 specifically, as any other version is either confirmed or speculated not to work. A plugin is also needed to read PSX binaries, which can be found here . After you have extracted the archive, open Ghidra, navigate to File -> Install Extensions in the main menu, and install the extension. Instructions for IDA Pro (WIP) Obtain the IDB file Install the psyq plugin Ignore \"psyq450: dir not found\" error How to extract PAK files You will need a tool called VibRipper, which can be found in this GitHub repository , courtesy of Resistiv. To use this tool, the executable will need to be placed in the same folder or directory as the PAK file you want to extract. After this, run the extract command, ./VibRipper.exe u 01_FILES.PAK EXTRACTED_FILES for example. (Append mono to the beginning in the case of Linux.) In this case, all the extracted files should be in EXTRACTED_FILES. If you wish to edit the files that you extracted, follow the other sections on this page accordingly. How to edit TMDs, ANMs, and ANCs The models and animations can be imported into 3D modeler programs, but there currently isn't a known way to export the models or animations into their respectable file formats. There are two currently known methods to edit models and animations. One uses Blender and the other uses LightWave. Blender Instructions If you want to export the animations on Blender, you can use a tool created by Murugo , who created a custom addon that can work with Vib-Ribbon's animation and model files; however the plugin was designed for Blender 2.8.x and as such will only work in that version range alone. For further instructions, visit the repository for the plugin . LightWave Instructions (WIP) It was discovered that LightWave was the tool used to create the original files, so naturally, there are methods to work with the models and animations here as well. You can get LightWave at this link . How to edit Audio files There is not a currently known way to edit the audio of Vib-Ribbon, but there will likely be one eventually. Looking at different SDKs will likely have some answers. Extracting the audios This is a simple process, and requires the use of PSound. You can download PSound by following this link. . Browse the folders with audio such as GAME/AUDIO/PSJ_SE.VB , KIOSK/AUDIO/PSJ_SE.VB , or TITLE/AUDIO/PSJ_SE.VB . Each piece of audio tends to be played at different speeds because sample rates vary across them. To export, you can convert them as WAV in the File Tab. How to edit obstacle data This one is still in the works... You can help us out by analyzing the SCRIPT/SYSTEM3.FSL file! After extraction, of course.","title":"Resources and Setup"},{"location":"decompilation/resources/#resources-and-setup","text":"","title":"Resources and Setup"},{"location":"decompilation/resources/#how-to-decompile","text":"If you want to help us research the game, and even reverse engineer, you will need the following things: Basic C and C++ knowledge A disassembler (IDA Pro or Ghidra is recommended)","title":"How to decompile"},{"location":"decompilation/resources/#instructions-for-ghidra","text":"You will need Ghidra 10.3.1 specifically, as any other version is either confirmed or speculated not to work. A plugin is also needed to read PSX binaries, which can be found here . After you have extracted the archive, open Ghidra, navigate to File -> Install Extensions in the main menu, and install the extension.","title":"Instructions for Ghidra"},{"location":"decompilation/resources/#instructions-for-ida-pro","text":"(WIP) Obtain the IDB file Install the psyq plugin Ignore \"psyq450: dir not found\" error","title":"Instructions for IDA Pro"},{"location":"decompilation/resources/#how-to-extract-pak-files","text":"You will need a tool called VibRipper, which can be found in this GitHub repository , courtesy of Resistiv. To use this tool, the executable will need to be placed in the same folder or directory as the PAK file you want to extract. After this, run the extract command, ./VibRipper.exe u 01_FILES.PAK EXTRACTED_FILES for example. (Append mono to the beginning in the case of Linux.) In this case, all the extracted files should be in EXTRACTED_FILES. If you wish to edit the files that you extracted, follow the other sections on this page accordingly.","title":"How to extract PAK files"},{"location":"decompilation/resources/#how-to-edit-tmds-anms-and-ancs","text":"The models and animations can be imported into 3D modeler programs, but there currently isn't a known way to export the models or animations into their respectable file formats. There are two currently known methods to edit models and animations. One uses Blender and the other uses LightWave.","title":"How to edit TMDs, ANMs, and ANCs"},{"location":"decompilation/resources/#blender-instructions","text":"If you want to export the animations on Blender, you can use a tool created by Murugo , who created a custom addon that can work with Vib-Ribbon's animation and model files; however the plugin was designed for Blender 2.8.x and as such will only work in that version range alone. For further instructions, visit the repository for the plugin .","title":"Blender Instructions"},{"location":"decompilation/resources/#lightwave-instructions","text":"(WIP) It was discovered that LightWave was the tool used to create the original files, so naturally, there are methods to work with the models and animations here as well. You can get LightWave at this link .","title":"LightWave Instructions"},{"location":"decompilation/resources/#how-to-edit-audio-files","text":"There is not a currently known way to edit the audio of Vib-Ribbon, but there will likely be one eventually. Looking at different SDKs will likely have some answers.","title":"How to edit Audio files"},{"location":"decompilation/resources/#extracting-the-audios","text":"This is a simple process, and requires the use of PSound. You can download PSound by following this link. . Browse the folders with audio such as GAME/AUDIO/PSJ_SE.VB , KIOSK/AUDIO/PSJ_SE.VB , or TITLE/AUDIO/PSJ_SE.VB . Each piece of audio tends to be played at different speeds because sample rates vary across them. To export, you can convert them as WAV in the File Tab.","title":"Extracting the audios"},{"location":"decompilation/resources/#how-to-edit-obstacle-data","text":"This one is still in the works... You can help us out by analyzing the SCRIPT/SYSTEM3.FSL file! After extraction, of course.","title":"How to edit obstacle data"},{"location":"decompilation/main_t/globals/","text":"Here are some of the globals found in MAIN_T.EXE, the title executable. These globals are saved as 4-byte DWORDS, usually as either values or pointers to game functions, in the console's memory during execution. PAL None yet.","title":"Globals"},{"location":"decompilation/main_t/globals/#pal","text":"None yet.","title":"PAL"},{"location":"file-types/anc/","text":"ANC - Camera Animation The ANC format store keyframes for a single camera animation. These files are used to control the camera during gameplay, menus and cutscenes. Longer animation sequences may be split into multiple .ANC files. File Layout .ANC 1 Header 0-n CameraKeyrame Header Offset Type Name Notes 0x00 int16 unk Always 0x8000 0x02 int16 unk Unused? Possible values: 1, 15, 20, 30, or 60 0x04 uint16 keyframeCount CameraKeyframe Offset Type Name Notes 0x00 int16 vpx Viewport X 0x02 int16 vpy Viewport Y 0x04 int16 vpz Viewport Z 0x06 int16 vrx Reference point X 0x08 int16 vry Reference point Y 0x0A int16 vrz Reference point Z 0x0C int16 rz Viewport twist. 0x1000 = 1\u00ba 0x0E int16 fov Field of view Each frame, the game orients the viewport camera by calling GsSetRefView2() with a static GsRVIEW2 object using parameters supplied by the current keyframe. This function call places the camera at coordinates (vpx, vpy, vpz) facing towards (vrx, vry, vrz) .","title":"ANC - Camera Animation"},{"location":"file-types/anc/#anc-camera-animation","text":"The ANC format store keyframes for a single camera animation. These files are used to control the camera during gameplay, menus and cutscenes. Longer animation sequences may be split into multiple .ANC files.","title":"ANC - Camera Animation"},{"location":"file-types/anc/#file-layout","text":".ANC 1 Header 0-n CameraKeyrame","title":"File Layout"},{"location":"file-types/anc/#header","text":"Offset Type Name Notes 0x00 int16 unk Always 0x8000 0x02 int16 unk Unused? Possible values: 1, 15, 20, 30, or 60 0x04 uint16 keyframeCount","title":"Header"},{"location":"file-types/anc/#camerakeyframe","text":"Offset Type Name Notes 0x00 int16 vpx Viewport X 0x02 int16 vpy Viewport Y 0x04 int16 vpz Viewport Z 0x06 int16 vrx Reference point X 0x08 int16 vry Reference point Y 0x0A int16 vrz Reference point Z 0x0C int16 rz Viewport twist. 0x1000 = 1\u00ba 0x0E int16 fov Field of view Each frame, the game orients the viewport camera by calling GsSetRefView2() with a static GsRVIEW2 object using parameters supplied by the current keyframe. This function call places the camera at coordinates (vpx, vpy, vpz) facing towards (vrx, vry, vrz) .","title":"CameraKeyframe"},{"location":"file-types/anm/","text":"ANM - Model Animation The ANM format stores keyframes for a TMD model animation. Longer animation sequences may be split into multiple .ANM files. File Layout .ANM 1 Header 0-n Frame 0-n Keyframe (per object) Header Offset Type Name Notes 0x00 int16 unk Always 0x8000 0x02 int16 unk Unused? Possible values: 1, 15, 20, 30, or 60 0x04 uint16 frameCount 0x06 uint16[] frameOffsetTable The frameOffsetTable array contains (frameCount + 1) elements. To find the start offset of frame n , multiply the value at index n by 2. The last entry marks the end offset of the file. Frame Offset Type Name Notes 0x00 Keyframe[] Contains keyframes for all keyed objects in the TMD for one animation frame. If an object index does not have a keyframe, it is not drawn for the current frame. There is no explicit count for the number of elements in the Keyframe array. To determine this count for frame n , continue processing the next Keyframe until reaching the end offset given by frameOffsetTable[n + 1] * 2 . Keyframe Offset Type Name Notes 0x00 uint8 objectIndex 0x01 uint8 flags int16 rotationX Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 rotationY Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 rotationZ Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 scaleX Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 scaleY Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 scaleZ Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 positionX Present if (flags & 0b100) > 0 . int16 positionY Present if (flags & 0b100) > 0 . int16 positionZ Present if (flags & 0b100) > 0 . Each keyframe animates an individual object in the TMD indicated by objectIndex . Rotation, scale and position keys are optional depending on the bits set in flags , and will always appear in that order.","title":"ANM - Model Animation"},{"location":"file-types/anm/#anm-model-animation","text":"The ANM format stores keyframes for a TMD model animation. Longer animation sequences may be split into multiple .ANM files.","title":"ANM - Model Animation"},{"location":"file-types/anm/#file-layout","text":".ANM 1 Header 0-n Frame 0-n Keyframe (per object)","title":"File Layout"},{"location":"file-types/anm/#header","text":"Offset Type Name Notes 0x00 int16 unk Always 0x8000 0x02 int16 unk Unused? Possible values: 1, 15, 20, 30, or 60 0x04 uint16 frameCount 0x06 uint16[] frameOffsetTable The frameOffsetTable array contains (frameCount + 1) elements. To find the start offset of frame n , multiply the value at index n by 2. The last entry marks the end offset of the file.","title":"Header"},{"location":"file-types/anm/#frame","text":"Offset Type Name Notes 0x00 Keyframe[] Contains keyframes for all keyed objects in the TMD for one animation frame. If an object index does not have a keyframe, it is not drawn for the current frame. There is no explicit count for the number of elements in the Keyframe array. To determine this count for frame n , continue processing the next Keyframe until reaching the end offset given by frameOffsetTable[n + 1] * 2 .","title":"Frame"},{"location":"file-types/anm/#keyframe","text":"Offset Type Name Notes 0x00 uint8 objectIndex 0x01 uint8 flags int16 rotationX Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 rotationY Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 rotationZ Present if (flags & 0b001) > 0 . Radians = value * 2\u03c0 / 4096 int16 scaleX Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 scaleY Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 scaleZ Present if (flags & 0b010) > 0 . Scale = value / 4096 int16 positionX Present if (flags & 0b100) > 0 . int16 positionY Present if (flags & 0b100) > 0 . int16 positionZ Present if (flags & 0b100) > 0 . Each keyframe animates an individual object in the TMD indicated by objectIndex . Rotation, scale and position keys are optional depending on the bits set in flags , and will always appear in that order.","title":"Keyframe"},{"location":"file-types/fsl/","text":"","title":"FSL - Obstacle Course Data"},{"location":"file-types/intro/","text":"","title":"Introduction to File Types"},{"location":"file-types/pak/","text":"PAK - Vib-Ribbon Archive Vib-Ribbon's PAK format is the primary data storage structure in the game. Compared to other propietary formats of archival from other games, this one is relatively simple. Several of them are laid throughout the game files. Unlike the usual ZIP, 7Z, or GZIP file, the contents are stored uncompressed, akin to a TAR archive, little endian. Of course, the files inside are indexed with a basic table of contents. File Makeup Header File Offset Table File Name File Length File Data (The last three are run through for each file that exists in the archive.) The short rundown of what each of the parts of the file do. The header, being only four bytes long, contains just the file count in the archive, stored as an unsigned integer, which can potentially carry up to 4.2 billion files inside... not that you'd want to though. There is also a series of offsets that the game creates pointers for that denotes the correct place where the beginning of the file should be. This is known as the offset table, also known as the \"table of contents.\" At each file offset, the file name is given first, including the directory. If the number of characters in the file name is not a multiple of four, there can be 1 to 3 null characters that pad to the next 4-byte sequence, which contains the length of the file in bytes, as an unsigned integer. Finally, the file data itself is placed after. PAK Implementations FILES.PAK and xx_FILES.PAK The PAK files for vib-ribbon are placed under GAME\\ , TITLE\\ , and KIOSK\\ , which are then used by their respective executable, and are unpacked during gameplay. In the Japanese game, all PAK files are named FILES.PAK , which cannot be said for the European version, because of the presence of multiple languages. Each language has a prefixed number at the beginning of its filename, and is written in base-16, double for each language. Some of the files contained also have this prefix, depending on whether there is translated text or not. 01_FILES - Japanese 02_FILES - English 04_FILES - German 08_FILES - Spanish 10_FILES - French 20_FILES - Italian TITLE\\FILES.PAK maintains the same name in the Japanese and European releases of vib-ribbon. Its translations are also included in the same directory as the file that is translated, because MAIN_T is able to change the language on the fly, whereas the setting is only carried over to MAIN_G and MAIN_K.","title":"PAK - Vib-Ribbon Archive"},{"location":"file-types/pak/#pak-vib-ribbon-archive","text":"Vib-Ribbon's PAK format is the primary data storage structure in the game. Compared to other propietary formats of archival from other games, this one is relatively simple. Several of them are laid throughout the game files. Unlike the usual ZIP, 7Z, or GZIP file, the contents are stored uncompressed, akin to a TAR archive, little endian. Of course, the files inside are indexed with a basic table of contents.","title":"PAK - Vib-Ribbon Archive"},{"location":"file-types/pak/#file-makeup","text":"Header File Offset Table File Name File Length File Data (The last three are run through for each file that exists in the archive.) The short rundown of what each of the parts of the file do. The header, being only four bytes long, contains just the file count in the archive, stored as an unsigned integer, which can potentially carry up to 4.2 billion files inside... not that you'd want to though. There is also a series of offsets that the game creates pointers for that denotes the correct place where the beginning of the file should be. This is known as the offset table, also known as the \"table of contents.\" At each file offset, the file name is given first, including the directory. If the number of characters in the file name is not a multiple of four, there can be 1 to 3 null characters that pad to the next 4-byte sequence, which contains the length of the file in bytes, as an unsigned integer. Finally, the file data itself is placed after.","title":"File Makeup"},{"location":"file-types/pak/#pak-implementations","text":"","title":"PAK Implementations"},{"location":"file-types/pak/#filespak-and-xx_filespak","text":"The PAK files for vib-ribbon are placed under GAME\\ , TITLE\\ , and KIOSK\\ , which are then used by their respective executable, and are unpacked during gameplay. In the Japanese game, all PAK files are named FILES.PAK , which cannot be said for the European version, because of the presence of multiple languages. Each language has a prefixed number at the beginning of its filename, and is written in base-16, double for each language. Some of the files contained also have this prefix, depending on whether there is translated text or not. 01_FILES - Japanese 02_FILES - English 04_FILES - German 08_FILES - Spanish 10_FILES - French 20_FILES - Italian TITLE\\FILES.PAK maintains the same name in the Japanese and European releases of vib-ribbon. Its translations are also included in the same directory as the file that is translated, because MAIN_T is able to change the language on the fly, whereas the setting is only carried over to MAIN_G and MAIN_K.","title":"FILES.PAK and xx_FILES.PAK"},{"location":"file-types/tim/","text":"TIM - PlayStation Image The TIM format is a little endian-based image file format for the PlayStation. While their use varies from textures, UI elements and loading screens, Vib-Ribbon only uses them for the company logos when the game starts up. It's file structure mimics how textures are managed in the PlayStation's VRAM. There are a limited amount of colors a TIM can use, but each file can use it's own 16 or 256 color palette, known as a color lookup table, or CLUT for short (16 and 24 bit color options are also avilable, but aren't used in Vib-Ribbon's textures.) Header Offset Type Name Notes 0x00 int8 ID Always 0x10 0x01 int8 Version Always 0x00 0x04 int8 Flag Possible Values: 0, 1, 2, 3, 4, 8, 9 Flag determines the color depth of the image and if it has its own CLUT. 0-3 represents either 4, 8, 16 and 24-bit color modes. A value of 4 is used if the TIM contains multiple types of sprite and texture data that need to be intermingled. 8 represents a 4-bit color depth that has its own CLUT, and 9 means the same but for 8-bit color depth. CLUT Header Offset Type Name Notes 0x00 int32 bnum Data length of the header + CLUT 0x04 int16 DX X Coordinate for VRAM placement 0x06 int16 DY Y Coordinate for VRAM placement 0x08 int16 H Horizontal resolution for placing CLUT in VRAM 0x08 int16 V Virtical resolution for placing CLUT in VRAM H and V have to equal 16 for 4-bit color depth and 256 for 8-bit color depth when multiplied. Supposedly you can change the resolution of CLUT to where it's more of a rectangle than a 256 pixel long line, possibly saving some space, but doing so will make the other colors go unused so it's not recommended. Keep H set to 16 or 256 and V to 1. CLUT Data Each color is recorded as a int16 value, but is read under binary. Each color is split into 5 bits, and the final bit is for transparency control, known as STP for short. Bits 0-4 are for Red, bits 5-9 are for Green, and bits 10-14 are for Blue. As for the STP, what it does depends on its value and the values of the previous bits. STP value Value of other Bits Result 0 All 0's Fully Transparent 0 Any value Non-Transparent color 1 All 0's Black, Non-Transparent 1 Any value Semi-Transparent color Pixel Header Offset Type Name Notes 0x00 int32 bnum Data length of the header + all pixel data 0x04 int16 DX X Coordinate for VRAM placement 0x06 int16 DY Y Coordinate for VRAM placement 0x08 int16 H Horizontal resolution of image in VRAM 0x08 int16 V Vertical resolution of image in VRAM The PlayStation's VRAM stores all images as 16-bit color depth. For 8 and 4-bit images, their H value need to be devided to load into the VRAM correctly, and will be corrected when displayed. For 8-bit images, H should be half of it's original horizontal resolution. For 4-bit, H is the original horizontal resolution devided by 4. Pixel Data How each pixel is recorded depends on the color depth of the image. For 4-bit color, 4 bits are used to specify what color from the CLUT will be used for that pixel. For 8-bit color, 8 bits are used to specify what color. For 16-bit color, every pixel uses the CLUT data format. 24-bit color is the most complex, using 3 int16 values. The first int16 value is used to store the red and green values, each taking up 8 bits. The second int16 value stores the blue value in the next set of 8 bits, but the following 8 bits is for the red color value of the next pixel. The last int16 value stores the green and blue values of the next pixel. Logos The only TIMs that are used in the game are at the beginning of MAIN_T execution. They are located in TITLE\\FILES\\MENU\\LOGOS\\ . Every TIM is a section of an image, and all of them get loaded and lined up to complete the image. SONY_X.TIM Make up the \"Sony Computer Entertainment Inc. Presents\" screen. Uses a 16 color (4 BPP) palette. Only used in the Japan version. Is present in the PAL version, but goes unused (renamed to 01_SONY_X.TIM ) SONY_1 + 2.TIM FE_SONY_X.TIM Make up the \"Sony Computer Entertainment Europe Presents\" screen, along with a URL to the European PlayStation Website. Uses a 16 color (4 BPP) palette. Only present in the PAL version. FE_SONY_1 + 2.TIM 7ON_X.TIM Make up the NanaOn-Sha logo. Uses a 256 color (8 BPP) palette, but not all colors are used. The amount of colors in the palette are also different between all 4 TIM files. 7ON_1 + 2,3,4.TIM","title":"TIM - PlayStation Image"},{"location":"file-types/tim/#tim-playstation-image","text":"The TIM format is a little endian-based image file format for the PlayStation. While their use varies from textures, UI elements and loading screens, Vib-Ribbon only uses them for the company logos when the game starts up. It's file structure mimics how textures are managed in the PlayStation's VRAM. There are a limited amount of colors a TIM can use, but each file can use it's own 16 or 256 color palette, known as a color lookup table, or CLUT for short (16 and 24 bit color options are also avilable, but aren't used in Vib-Ribbon's textures.)","title":"TIM - PlayStation Image"},{"location":"file-types/tim/#header","text":"Offset Type Name Notes 0x00 int8 ID Always 0x10 0x01 int8 Version Always 0x00 0x04 int8 Flag Possible Values: 0, 1, 2, 3, 4, 8, 9 Flag determines the color depth of the image and if it has its own CLUT. 0-3 represents either 4, 8, 16 and 24-bit color modes. A value of 4 is used if the TIM contains multiple types of sprite and texture data that need to be intermingled. 8 represents a 4-bit color depth that has its own CLUT, and 9 means the same but for 8-bit color depth.","title":"Header"},{"location":"file-types/tim/#clut-header","text":"Offset Type Name Notes 0x00 int32 bnum Data length of the header + CLUT 0x04 int16 DX X Coordinate for VRAM placement 0x06 int16 DY Y Coordinate for VRAM placement 0x08 int16 H Horizontal resolution for placing CLUT in VRAM 0x08 int16 V Virtical resolution for placing CLUT in VRAM H and V have to equal 16 for 4-bit color depth and 256 for 8-bit color depth when multiplied. Supposedly you can change the resolution of CLUT to where it's more of a rectangle than a 256 pixel long line, possibly saving some space, but doing so will make the other colors go unused so it's not recommended. Keep H set to 16 or 256 and V to 1.","title":"CLUT Header"},{"location":"file-types/tim/#clut-data","text":"Each color is recorded as a int16 value, but is read under binary. Each color is split into 5 bits, and the final bit is for transparency control, known as STP for short. Bits 0-4 are for Red, bits 5-9 are for Green, and bits 10-14 are for Blue. As for the STP, what it does depends on its value and the values of the previous bits. STP value Value of other Bits Result 0 All 0's Fully Transparent 0 Any value Non-Transparent color 1 All 0's Black, Non-Transparent 1 Any value Semi-Transparent color","title":"CLUT Data"},{"location":"file-types/tim/#pixel-header","text":"Offset Type Name Notes 0x00 int32 bnum Data length of the header + all pixel data 0x04 int16 DX X Coordinate for VRAM placement 0x06 int16 DY Y Coordinate for VRAM placement 0x08 int16 H Horizontal resolution of image in VRAM 0x08 int16 V Vertical resolution of image in VRAM The PlayStation's VRAM stores all images as 16-bit color depth. For 8 and 4-bit images, their H value need to be devided to load into the VRAM correctly, and will be corrected when displayed. For 8-bit images, H should be half of it's original horizontal resolution. For 4-bit, H is the original horizontal resolution devided by 4.","title":"Pixel Header"},{"location":"file-types/tim/#pixel-data","text":"How each pixel is recorded depends on the color depth of the image. For 4-bit color, 4 bits are used to specify what color from the CLUT will be used for that pixel. For 8-bit color, 8 bits are used to specify what color. For 16-bit color, every pixel uses the CLUT data format. 24-bit color is the most complex, using 3 int16 values. The first int16 value is used to store the red and green values, each taking up 8 bits. The second int16 value stores the blue value in the next set of 8 bits, but the following 8 bits is for the red color value of the next pixel. The last int16 value stores the green and blue values of the next pixel.","title":"Pixel Data"},{"location":"file-types/tim/#logos","text":"The only TIMs that are used in the game are at the beginning of MAIN_T execution. They are located in TITLE\\FILES\\MENU\\LOGOS\\ . Every TIM is a section of an image, and all of them get loaded and lined up to complete the image. SONY_X.TIM Make up the \"Sony Computer Entertainment Inc. Presents\" screen. Uses a 16 color (4 BPP) palette. Only used in the Japan version. Is present in the PAL version, but goes unused (renamed to 01_SONY_X.TIM ) SONY_1 + 2.TIM FE_SONY_X.TIM Make up the \"Sony Computer Entertainment Europe Presents\" screen, along with a URL to the European PlayStation Website. Uses a 16 color (4 BPP) palette. Only present in the PAL version. FE_SONY_1 + 2.TIM 7ON_X.TIM Make up the NanaOn-Sha logo. Uses a 256 color (8 BPP) palette, but not all colors are used. The amount of colors in the palette are also different between all 4 TIM files. 7ON_1 + 2,3,4.TIM","title":"Logos"},{"location":"file-types/tmd/","text":".flex-container { display: flex; flex-wrap: nowrap; } TMD - PlayStation Model Like every three-dimensional object in a video game, a character such as Vibri, would need a 3d model in order to convey what the player is doing. Despite previous confusion within the confines of the Vib-Ribbon community, this is no exception for Vibri. The format in which Vib-Ribbon uses for its models is the TMD format, which is useful for keeping filesize down in order to integrate Vib-Ribbon into the RAM of the Playstation. These files tend to be small to the point where multiple tens, or maybe even a couple hundred could theoretically fit inside the base 2 megabytes of system memory on the PlayStation. Vib-Ribbon makes use of these model files rather extensively compared other games due to the visual style of the game. From characters, to the ribbon itself, to even the font that the game uses, everything that is a vector traces back to one of these models. However, if imported straight into a program, such as Blender, you\u2019ll only get pieces of a model that aren\u2019t put together. It\u2019s up to the ANM files to put them together. And because of the fact that the objects that make up each file are polylines, as opposed to polygons, they may render as invisible or otherwise incorrect or strange unless the user turns on some sort of wireframe mode. File Makeup Header Object Table Primitives Vertices Normals The short rundown of what each of the parts of the file do. The header indicates the version of the TMD, any flags that the TMD needs to set and the number of objects in the file. The object table, you guessed it, lists the pointers to all the objects. Primitives are arrangments of drawing packets, being: polygons, lines, and sprites. Vertices, obviously, are the points for all the objects. Normals help with shading, which is completely irrelevant for vib-ribbon. TMD Implementations Fonts As stated before, all vector objects are loaded from TMD files, including the font files. The PAL version of the game uses one of two main font files depending on what the language is set to from the menu. An oddity that can be seen is that all of the Japanese files, including the katakana font, is still in the European version, inside 01_FILES , but are left only used in the Japanese release. Each FONT folder contains two TMDs, FE_FONT.TMD ( 01_FONT.TMD for Japanese) and MARK.TMD . The actual symbols used to make sentences are made from FE_FONT.TMD , whereas MARK.TMD contains shape-represenations for scoring. One thing to note is that the numbers saved in 01_FONT.TMD are wider than they are in FE_FONT.TMD , probably because of the katakana also written in the Japanese file. MARK.TMD FE_FONT.TMD 01_FONT.TMD Vibri There are three variants of Vibri's rabbit form inside of the games files, a different variant is used for each executable of the game. These three files, to reduce confusion, only contain Vibri\u2019s rabbit form, as her other forms are located in other files. A major thing about Vibri's model to be known is that this one is not meant to be looked at from all directions, as this model takes a slightly more \"two-dimensional\" approach. The one used for MAIN_T is located in TITLE\\FILES\\MOVIE\\TITLE\\ , which is a 8120-byte file named VIBRI.TMD . It is used for the title screen, and contains most of the same objects as MAIN_G's Vibri model, with the exception of omitting a few of them, which seem to relate to arms. MAIN_G's Vibri rabbit model is a 8528-byte file titled two different things depending on where it comes from. As such, the same file is located in two different places at all times, GAME\\xx_FILES\\TITLE\\VIBRI\\ and GAME\\xx_FILES\\CHARA\\PEELOO\\ , where the files are named VIBRI.TMD and MODEL.TMD respectively. The former is used for the game menus, where the other is used for gameplay. During gameplay, the game also loads her other forms from the FROG , SNAKE , and SUPER folders, also located in GAME\\xx_FILES\\CHARA\\ , all of which also called MODEL.TMD . The folders also contain all the ANM files for the respective forms, as they of course, cannot share the same ones. And finally, the third variant of the Vibri model is the smallest, being comprised of only 4400 bytes. This one is used during MAIN_K's execution -- which is the tutorial. It is not only smaller in file size, but it is also curiously smaller in physical size. This file is located in KIOSK\\xx_FILES\\MOVIE\\KIOSK2\\ and is named MODEL.TMD . As stated before, Vibri's model has to adapt to the position of the camera as all of her limbs are flat, taking the camera to a different / unintended position reveals a few things about Vibri that suggest that the third dimension was used to help make certain details. Certain angles are still applied to some of the limbs of Vibri. In the example gif for example, you can notice how her feet and her arms are tilted, which is usually not though about when rendered into the game. Her torso is also a full cone-like structure rather than a plane like the rest of the model's objects. Perhaps the most noticable, her eyes also pertrude from the rest of the face, likely as either a way to make them appear thinner than they really are, or to make them scale more naturally when turning. A final thing you may notice is the triangle that appears on her head. This might have been used as a way to help center the head during the animating process. This triangle of course, does not show up in the actual game. In all of the models for Vibri, the eyes are only visible from one side because the PlayStation is able to hide any object from the backside.","title":"TMD - PlayStation Model"},{"location":"file-types/tmd/#tmd-playstation-model","text":"Like every three-dimensional object in a video game, a character such as Vibri, would need a 3d model in order to convey what the player is doing. Despite previous confusion within the confines of the Vib-Ribbon community, this is no exception for Vibri. The format in which Vib-Ribbon uses for its models is the TMD format, which is useful for keeping filesize down in order to integrate Vib-Ribbon into the RAM of the Playstation. These files tend to be small to the point where multiple tens, or maybe even a couple hundred could theoretically fit inside the base 2 megabytes of system memory on the PlayStation. Vib-Ribbon makes use of these model files rather extensively compared other games due to the visual style of the game. From characters, to the ribbon itself, to even the font that the game uses, everything that is a vector traces back to one of these models. However, if imported straight into a program, such as Blender, you\u2019ll only get pieces of a model that aren\u2019t put together. It\u2019s up to the ANM files to put them together. And because of the fact that the objects that make up each file are polylines, as opposed to polygons, they may render as invisible or otherwise incorrect or strange unless the user turns on some sort of wireframe mode.","title":"TMD - PlayStation Model"},{"location":"file-types/tmd/#file-makeup","text":"Header Object Table Primitives Vertices Normals The short rundown of what each of the parts of the file do. The header indicates the version of the TMD, any flags that the TMD needs to set and the number of objects in the file. The object table, you guessed it, lists the pointers to all the objects. Primitives are arrangments of drawing packets, being: polygons, lines, and sprites. Vertices, obviously, are the points for all the objects. Normals help with shading, which is completely irrelevant for vib-ribbon.","title":"File Makeup"},{"location":"file-types/tmd/#tmd-implementations","text":"","title":"TMD Implementations"},{"location":"file-types/tmd/#fonts","text":"As stated before, all vector objects are loaded from TMD files, including the font files. The PAL version of the game uses one of two main font files depending on what the language is set to from the menu. An oddity that can be seen is that all of the Japanese files, including the katakana font, is still in the European version, inside 01_FILES , but are left only used in the Japanese release. Each FONT folder contains two TMDs, FE_FONT.TMD ( 01_FONT.TMD for Japanese) and MARK.TMD . The actual symbols used to make sentences are made from FE_FONT.TMD , whereas MARK.TMD contains shape-represenations for scoring. One thing to note is that the numbers saved in 01_FONT.TMD are wider than they are in FE_FONT.TMD , probably because of the katakana also written in the Japanese file. MARK.TMD FE_FONT.TMD 01_FONT.TMD","title":"Fonts"},{"location":"file-types/tmd/#vibri","text":"There are three variants of Vibri's rabbit form inside of the games files, a different variant is used for each executable of the game. These three files, to reduce confusion, only contain Vibri\u2019s rabbit form, as her other forms are located in other files. A major thing about Vibri's model to be known is that this one is not meant to be looked at from all directions, as this model takes a slightly more \"two-dimensional\" approach. The one used for MAIN_T is located in TITLE\\FILES\\MOVIE\\TITLE\\ , which is a 8120-byte file named VIBRI.TMD . It is used for the title screen, and contains most of the same objects as MAIN_G's Vibri model, with the exception of omitting a few of them, which seem to relate to arms. MAIN_G's Vibri rabbit model is a 8528-byte file titled two different things depending on where it comes from. As such, the same file is located in two different places at all times, GAME\\xx_FILES\\TITLE\\VIBRI\\ and GAME\\xx_FILES\\CHARA\\PEELOO\\ , where the files are named VIBRI.TMD and MODEL.TMD respectively. The former is used for the game menus, where the other is used for gameplay. During gameplay, the game also loads her other forms from the FROG , SNAKE , and SUPER folders, also located in GAME\\xx_FILES\\CHARA\\ , all of which also called MODEL.TMD . The folders also contain all the ANM files for the respective forms, as they of course, cannot share the same ones. And finally, the third variant of the Vibri model is the smallest, being comprised of only 4400 bytes. This one is used during MAIN_K's execution -- which is the tutorial. It is not only smaller in file size, but it is also curiously smaller in physical size. This file is located in KIOSK\\xx_FILES\\MOVIE\\KIOSK2\\ and is named MODEL.TMD . As stated before, Vibri's model has to adapt to the position of the camera as all of her limbs are flat, taking the camera to a different / unintended position reveals a few things about Vibri that suggest that the third dimension was used to help make certain details. Certain angles are still applied to some of the limbs of Vibri. In the example gif for example, you can notice how her feet and her arms are tilted, which is usually not though about when rendered into the game. Her torso is also a full cone-like structure rather than a plane like the rest of the model's objects. Perhaps the most noticable, her eyes also pertrude from the rest of the face, likely as either a way to make them appear thinner than they really are, or to make them scale more naturally when turning. A final thing you may notice is the triangle that appears on her head. This might have been used as a way to help center the head during the animating process. This triangle of course, does not show up in the actual game. In all of the models for Vibri, the eyes are only visible from one side because the PlayStation is able to hide any object from the backside.","title":"Vibri"},{"location":"file-types/vb-vh/","text":"","title":"VB/VH - PlayStation Audio"}]}